/*
 * generated by Xtext 2.10.0
 */
package fr.inria.diverse.docl.serializer;

import com.google.inject.Inject;
import fr.inria.diverse.docl.docl.AddOpCallExp;
import fr.inria.diverse.docl.docl.BagType;
import fr.inria.diverse.docl.docl.BoolOpCallExp;
import fr.inria.diverse.docl.docl.BooleanLiteralExp;
import fr.inria.diverse.docl.docl.BooleanType;
import fr.inria.diverse.docl.docl.CollectionOpCallExp;
import fr.inria.diverse.docl.docl.ComOpCallExp;
import fr.inria.diverse.docl.docl.DoclPackage;
import fr.inria.diverse.docl.docl.ElseIfThenExp;
import fr.inria.diverse.docl.docl.EnvType;
import fr.inria.diverse.docl.docl.EqOpCallExp;
import fr.inria.diverse.docl.docl.IfExp;
import fr.inria.diverse.docl.docl.Import;
import fr.inria.diverse.docl.docl.IntegerType;
import fr.inria.diverse.docl.docl.InvalidLiteralExp;
import fr.inria.diverse.docl.docl.IterateExp;
import fr.inria.diverse.docl.docl.Iterator;
import fr.inria.diverse.docl.docl.IteratorExp;
import fr.inria.diverse.docl.docl.LambdaExp;
import fr.inria.diverse.docl.docl.LambdaType;
import fr.inria.diverse.docl.docl.LocalVariable;
import fr.inria.diverse.docl.docl.MapType;
import fr.inria.diverse.docl.docl.Module;
import fr.inria.diverse.docl.docl.MulOpCallExp;
import fr.inria.diverse.docl.docl.NavigationExp;
import fr.inria.diverse.docl.docl.NavigationOrAttributeCall;
import fr.inria.diverse.docl.docl.NestedExp;
import fr.inria.diverse.docl.docl.NullLiteralExp;
import fr.inria.diverse.docl.docl.NumberLiteralExp;
import fr.inria.diverse.docl.docl.OclAnyType;
import fr.inria.diverse.docl.docl.OclExpression;
import fr.inria.diverse.docl.docl.OclModel;
import fr.inria.diverse.docl.docl.OclModelElementExp;
import fr.inria.diverse.docl.docl.OperationCall;
import fr.inria.diverse.docl.docl.OrderedSetType;
import fr.inria.diverse.docl.docl.Query;
import fr.inria.diverse.docl.docl.RealType;
import fr.inria.diverse.docl.docl.SelfExp;
import fr.inria.diverse.docl.docl.SequenceType;
import fr.inria.diverse.docl.docl.SetType;
import fr.inria.diverse.docl.docl.StringLiteralExp;
import fr.inria.diverse.docl.docl.StringType;
import fr.inria.diverse.docl.docl.TupleExp;
import fr.inria.diverse.docl.docl.TuplePart;
import fr.inria.diverse.docl.docl.URI_;
import fr.inria.diverse.docl.docl.UnlimitedNaturalLiteralExp;
import fr.inria.diverse.docl.services.DOclGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class DOclSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DOclGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DoclPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DoclPackage.ADD_OP_CALL_EXP:
				sequence_AdditionOpExp(context, (AddOpCallExp) semanticObject); 
				return; 
			case DoclPackage.BAG_TYPE:
				sequence_BagType(context, (BagType) semanticObject); 
				return; 
			case DoclPackage.BOOL_OP_CALL_EXP:
				if (rule == grammarAccess.getAndOpExpRule()
						|| action == grammarAccess.getAndOpExpAccess().getBoolOpCallExpSourceAction_1_0()) {
					sequence_AndOpExp(context, (BoolOpCallExp) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOclExpressionRule()
						|| rule == grammarAccess.getImpliesOpExpRule()
						|| action == grammarAccess.getImpliesOpExpAccess().getBoolOpCallExpSourceAction_1_0()) {
					sequence_AndOpExp_ImpliesOpExp_OrOpExp_XorOpExp(context, (BoolOpCallExp) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOrOpExpRule()
						|| action == grammarAccess.getOrOpExpAccess().getBoolOpCallExpSourceAction_1_0()) {
					sequence_AndOpExp_OrOpExp(context, (BoolOpCallExp) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getXorOpExpRule()
						|| action == grammarAccess.getXorOpExpAccess().getBoolOpCallExpSourceAction_1_0()) {
					sequence_AndOpExp_OrOpExp_XorOpExp(context, (BoolOpCallExp) semanticObject); 
					return; 
				}
				else break;
			case DoclPackage.BOOLEAN_LITERAL_EXP:
				sequence_BooleanExp(context, (BooleanLiteralExp) semanticObject); 
				return; 
			case DoclPackage.BOOLEAN_TYPE:
				sequence_BooleanType(context, (BooleanType) semanticObject); 
				return; 
			case DoclPackage.COLLECTION_OP_CALL_EXP:
				sequence_CollectionOpCall(context, (CollectionOpCallExp) semanticObject); 
				return; 
			case DoclPackage.COM_OP_CALL_EXP:
				sequence_ComparisonOpExp(context, (ComOpCallExp) semanticObject); 
				return; 
			case DoclPackage.ELSE_IF_THEN_EXP:
				sequence_ElseIfThenExp(context, (ElseIfThenExp) semanticObject); 
				return; 
			case DoclPackage.ENV_TYPE:
				sequence_EnvType(context, (EnvType) semanticObject); 
				return; 
			case DoclPackage.EQ_OP_CALL_EXP:
				sequence_EqOpExp(context, (EqOpCallExp) semanticObject); 
				return; 
			case DoclPackage.IF_EXP:
				sequence_IfExp(context, (IfExp) semanticObject); 
				return; 
			case DoclPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case DoclPackage.INTEGER_TYPE:
				sequence_IntegerType(context, (IntegerType) semanticObject); 
				return; 
			case DoclPackage.INVALID_LITERAL_EXP:
				sequence_InvalidExp(context, (InvalidLiteralExp) semanticObject); 
				return; 
			case DoclPackage.ITERATE_EXP:
				sequence_IterateExp(context, (IterateExp) semanticObject); 
				return; 
			case DoclPackage.ITERATOR:
				sequence_Iterator(context, (Iterator) semanticObject); 
				return; 
			case DoclPackage.ITERATOR_EXP:
				sequence_IteratorExp(context, (IteratorExp) semanticObject); 
				return; 
			case DoclPackage.LAMBDA_EXP:
				sequence_LambdaExp(context, (LambdaExp) semanticObject); 
				return; 
			case DoclPackage.LAMBDA_TYPE:
				sequence_LambdaType(context, (LambdaType) semanticObject); 
				return; 
			case DoclPackage.LOCAL_VARIABLE:
				sequence_LocalVariable(context, (LocalVariable) semanticObject); 
				return; 
			case DoclPackage.MAP_TYPE:
				sequence_MapType(context, (MapType) semanticObject); 
				return; 
			case DoclPackage.MODULE:
				sequence_Module(context, (Module) semanticObject); 
				return; 
			case DoclPackage.MUL_OP_CALL_EXP:
				sequence_MultiOpExp(context, (MulOpCallExp) semanticObject); 
				return; 
			case DoclPackage.NAVIGATION_EXP:
				sequence_NavOpExp(context, (NavigationExp) semanticObject); 
				return; 
			case DoclPackage.NAVIGATION_OR_ATTRIBUTE_CALL:
				sequence_NavigationOrAttributeCall(context, (NavigationOrAttributeCall) semanticObject); 
				return; 
			case DoclPackage.NESTED_EXP:
				sequence_NestedExp(context, (NestedExp) semanticObject); 
				return; 
			case DoclPackage.NULL_LITERAL_EXP:
				sequence_NullExp(context, (NullLiteralExp) semanticObject); 
				return; 
			case DoclPackage.NUMBER_LITERAL_EXP:
				sequence_NumberExp(context, (NumberLiteralExp) semanticObject); 
				return; 
			case DoclPackage.OCL_ANY_TYPE:
				sequence_OclAnyType(context, (OclAnyType) semanticObject); 
				return; 
			case DoclPackage.OCL_EXPRESSION:
				if (rule == grammarAccess.getLetExpRule()) {
					sequence_LetExp(context, (OclExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOclExpressionRule()) {
					sequence_LetExp_OclModelElementExp_UnaryOpExp(context, (OclExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getImpliesOpExpRule()
						|| action == grammarAccess.getImpliesOpExpAccess().getBoolOpCallExpSourceAction_1_0()
						|| rule == grammarAccess.getXorOpExpRule()
						|| action == grammarAccess.getXorOpExpAccess().getBoolOpCallExpSourceAction_1_0()
						|| rule == grammarAccess.getOrOpExpRule()
						|| action == grammarAccess.getOrOpExpAccess().getBoolOpCallExpSourceAction_1_0()
						|| rule == grammarAccess.getAndOpExpRule()
						|| action == grammarAccess.getAndOpExpAccess().getBoolOpCallExpSourceAction_1_0()
						|| rule == grammarAccess.getEqOpExpRule()
						|| action == grammarAccess.getEqOpExpAccess().getEqOpCallExpSourceAction_1_0()
						|| rule == grammarAccess.getComparisonOpExpRule()
						|| action == grammarAccess.getComparisonOpExpAccess().getComOpCallExpSourceAction_1_0()
						|| rule == grammarAccess.getAdditionOpExpRule()
						|| action == grammarAccess.getAdditionOpExpAccess().getAddOpCallExpSourceAction_1_0()
						|| rule == grammarAccess.getMultiOpExpRule()
						|| action == grammarAccess.getMultiOpExpAccess().getMulOpCallExpSourceAction_1_0()
						|| rule == grammarAccess.getNavOpExpRule()
						|| action == grammarAccess.getNavOpExpAccess().getNavigationExpSourceAction_1_0()
						|| rule == grammarAccess.getNavigationOpCallExpRule()
						|| rule == grammarAccess.getOclModelElementExpRule()
						|| rule == grammarAccess.getPrimaryExpRule()) {
					sequence_OclModelElementExp(context, (OclExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getUnaryOpExpRule()) {
					sequence_UnaryOpExp(context, (OclExpression) semanticObject); 
					return; 
				}
				else break;
			case DoclPackage.OCL_MODEL:
				sequence_OclModel(context, (OclModel) semanticObject); 
				return; 
			case DoclPackage.OCL_MODEL_ELEMENT_EXP:
				sequence_OclModelElement(context, (OclModelElementExp) semanticObject); 
				return; 
			case DoclPackage.OPERATION_CALL:
				if (rule == grammarAccess.getAllInstancesOpCallRule()) {
					sequence_AllInstancesOpCall(context, (OperationCall) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getOclExpressionRule()
						|| rule == grammarAccess.getImpliesOpExpRule()
						|| action == grammarAccess.getImpliesOpExpAccess().getBoolOpCallExpSourceAction_1_0()
						|| rule == grammarAccess.getXorOpExpRule()
						|| action == grammarAccess.getXorOpExpAccess().getBoolOpCallExpSourceAction_1_0()
						|| rule == grammarAccess.getOrOpExpRule()
						|| action == grammarAccess.getOrOpExpAccess().getBoolOpCallExpSourceAction_1_0()
						|| rule == grammarAccess.getAndOpExpRule()
						|| action == grammarAccess.getAndOpExpAccess().getBoolOpCallExpSourceAction_1_0()
						|| rule == grammarAccess.getEqOpExpRule()
						|| action == grammarAccess.getEqOpExpAccess().getEqOpCallExpSourceAction_1_0()
						|| rule == grammarAccess.getComparisonOpExpRule()
						|| action == grammarAccess.getComparisonOpExpAccess().getComOpCallExpSourceAction_1_0()
						|| rule == grammarAccess.getAdditionOpExpRule()
						|| action == grammarAccess.getAdditionOpExpAccess().getAddOpCallExpSourceAction_1_0()
						|| rule == grammarAccess.getMultiOpExpRule()
						|| action == grammarAccess.getMultiOpExpAccess().getMulOpCallExpSourceAction_1_0()
						|| rule == grammarAccess.getNavOpExpRule()
						|| action == grammarAccess.getNavOpExpAccess().getNavigationExpSourceAction_1_0()
						|| rule == grammarAccess.getNavigationOpCallExpRule()
						|| rule == grammarAccess.getOperationCallRule()) {
					sequence_OperationCall(context, (OperationCall) semanticObject); 
					return; 
				}
				else break;
			case DoclPackage.ORDERED_SET_TYPE:
				sequence_OrderedSetType(context, (OrderedSetType) semanticObject); 
				return; 
			case DoclPackage.QUERY:
				sequence_Query(context, (Query) semanticObject); 
				return; 
			case DoclPackage.REAL_TYPE:
				sequence_RealType(context, (RealType) semanticObject); 
				return; 
			case DoclPackage.SELF_EXP:
				sequence_SeflExp(context, (SelfExp) semanticObject); 
				return; 
			case DoclPackage.SEQUENCE_TYPE:
				sequence_SequenceType(context, (SequenceType) semanticObject); 
				return; 
			case DoclPackage.SET_TYPE:
				sequence_SetType(context, (SetType) semanticObject); 
				return; 
			case DoclPackage.STRING_LITERAL_EXP:
				sequence_StringExp(context, (StringLiteralExp) semanticObject); 
				return; 
			case DoclPackage.STRING_TYPE:
				sequence_StringType(context, (StringType) semanticObject); 
				return; 
			case DoclPackage.TUPLE_EXP:
				sequence_TupleExp(context, (TupleExp) semanticObject); 
				return; 
			case DoclPackage.TUPLE_PART:
				sequence_TuplePart(context, (TuplePart) semanticObject); 
				return; 
			case DoclPackage.URI_:
				sequence_URI_(context, (URI_) semanticObject); 
				return; 
			case DoclPackage.UNLIMITED_NATURAL_LITERAL_EXP:
				sequence_UnlimitedNaturalExp(context, (UnlimitedNaturalLiteralExp) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     OclExpression returns AddOpCallExp
	 *     ImpliesOpExp returns AddOpCallExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns AddOpCallExp
	 *     XorOpExp returns AddOpCallExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns AddOpCallExp
	 *     OrOpExp returns AddOpCallExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns AddOpCallExp
	 *     AndOpExp returns AddOpCallExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns AddOpCallExp
	 *     EqOpExp returns AddOpCallExp
	 *     EqOpExp.EqOpCallExp_1_0 returns AddOpCallExp
	 *     ComparisonOpExp returns AddOpCallExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns AddOpCallExp
	 *     AdditionOpExp returns AddOpCallExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns AddOpCallExp
	 *
	 * Constraint:
	 *     (source=AdditionOpExp_AddOpCallExp_1_0 (name='+' | name='-') target=MultiOpExp)
	 */
	protected void sequence_AdditionOpExp(ISerializationContext context, AddOpCallExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AllInstancesOpCall returns OperationCall
	 *
	 * Constraint:
	 *     name='allInstances'
	 */
	protected void sequence_AllInstancesOpCall(ISerializationContext context, OperationCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.OCL_EXPRESSION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.OCL_EXPRESSION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAllInstancesOpCallAccess().getNameAllInstancesKeyword_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AndOpExp returns BoolOpCallExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns BoolOpCallExp
	 *
	 * Constraint:
	 *     (source=AndOpExp_BoolOpCallExp_1_0 name=AndOperator target=EqOpExp)
	 */
	protected void sequence_AndOpExp(ISerializationContext context, BoolOpCallExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.BOOL_OP_CALL_EXP__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.BOOL_OP_CALL_EXP__SOURCE));
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.OCL_EXPRESSION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.OCL_EXPRESSION__NAME));
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.OCL_EXPRESSION__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.OCL_EXPRESSION__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndOpExpAccess().getBoolOpCallExpSourceAction_1_0(), semanticObject.getSource());
		feeder.accept(grammarAccess.getAndOpExpAccess().getNameAndOperatorParserRuleCall_1_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAndOpExpAccess().getTargetEqOpExpParserRuleCall_1_2_0(), semanticObject.getTarget());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns BoolOpCallExp
	 *     ImpliesOpExp returns BoolOpCallExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns BoolOpCallExp
	 *
	 * Constraint:
	 *     (
	 *         (source=ImpliesOpExp_BoolOpCallExp_1_0 name=ImpliesOperator target=XorOpExp) | 
	 *         (source=XorOpExp_BoolOpCallExp_1_0 name=XorOperator target=OrOpExp) | 
	 *         (source=OrOpExp_BoolOpCallExp_1_0 name=OrOperator target=AndOpExp) | 
	 *         (source=AndOpExp_BoolOpCallExp_1_0 name=AndOperator target=EqOpExp)
	 *     )
	 */
	protected void sequence_AndOpExp_ImpliesOpExp_OrOpExp_XorOpExp(ISerializationContext context, BoolOpCallExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OrOpExp returns BoolOpCallExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns BoolOpCallExp
	 *
	 * Constraint:
	 *     ((source=OrOpExp_BoolOpCallExp_1_0 name=OrOperator target=AndOpExp) | (source=AndOpExp_BoolOpCallExp_1_0 name=AndOperator target=EqOpExp))
	 */
	protected void sequence_AndOpExp_OrOpExp(ISerializationContext context, BoolOpCallExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XorOpExp returns BoolOpCallExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns BoolOpCallExp
	 *
	 * Constraint:
	 *     (
	 *         (source=XorOpExp_BoolOpCallExp_1_0 name=XorOperator target=OrOpExp) | 
	 *         (source=OrOpExp_BoolOpCallExp_1_0 name=OrOperator target=AndOpExp) | 
	 *         (source=AndOpExp_BoolOpCallExp_1_0 name=AndOperator target=EqOpExp)
	 *     )
	 */
	protected void sequence_AndOpExp_OrOpExp_XorOpExp(ISerializationContext context, BoolOpCallExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclType returns BagType
	 *     BagType returns BagType
	 *
	 * Constraint:
	 *     (name='BagType' elementType=OclType)
	 */
	protected void sequence_BagType(ISerializationContext context, BagType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.BAG_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.BAG_TYPE__NAME));
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.BAG_TYPE__ELEMENT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.BAG_TYPE__ELEMENT_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBagTypeAccess().getNameBagTypeKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getBagTypeAccess().getElementTypeOclTypeParserRuleCall_2_0(), semanticObject.getElementType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns BooleanLiteralExp
	 *     ImpliesOpExp returns BooleanLiteralExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns BooleanLiteralExp
	 *     XorOpExp returns BooleanLiteralExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns BooleanLiteralExp
	 *     OrOpExp returns BooleanLiteralExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns BooleanLiteralExp
	 *     AndOpExp returns BooleanLiteralExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns BooleanLiteralExp
	 *     EqOpExp returns BooleanLiteralExp
	 *     EqOpExp.EqOpCallExp_1_0 returns BooleanLiteralExp
	 *     ComparisonOpExp returns BooleanLiteralExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns BooleanLiteralExp
	 *     AdditionOpExp returns BooleanLiteralExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns BooleanLiteralExp
	 *     MultiOpExp returns BooleanLiteralExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns BooleanLiteralExp
	 *     NavOpExp returns BooleanLiteralExp
	 *     NavOpExp.NavigationExp_1_0 returns BooleanLiteralExp
	 *     NavigationOpCallExp returns BooleanLiteralExp
	 *     PrimaryExp returns BooleanLiteralExp
	 *     PrimitiveExp returns BooleanLiteralExp
	 *     BooleanExp returns BooleanLiteralExp
	 *
	 * Constraint:
	 *     (symbol='true' | symbol='false')
	 */
	protected void sequence_BooleanExp(ISerializationContext context, BooleanLiteralExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclType returns BooleanType
	 *     BooleanType returns BooleanType
	 *
	 * Constraint:
	 *     name='Boolean'
	 */
	protected void sequence_BooleanType(ISerializationContext context, BooleanType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.BOOLEAN_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.BOOLEAN_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanTypeAccess().getNameBooleanKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns CollectionOpCallExp
	 *     ImpliesOpExp returns CollectionOpCallExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns CollectionOpCallExp
	 *     XorOpExp returns CollectionOpCallExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns CollectionOpCallExp
	 *     OrOpExp returns CollectionOpCallExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns CollectionOpCallExp
	 *     AndOpExp returns CollectionOpCallExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns CollectionOpCallExp
	 *     EqOpExp returns CollectionOpCallExp
	 *     EqOpExp.EqOpCallExp_1_0 returns CollectionOpCallExp
	 *     ComparisonOpExp returns CollectionOpCallExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns CollectionOpCallExp
	 *     AdditionOpExp returns CollectionOpCallExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns CollectionOpCallExp
	 *     MultiOpExp returns CollectionOpCallExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns CollectionOpCallExp
	 *     NavOpExp returns CollectionOpCallExp
	 *     NavOpExp.NavigationExp_1_0 returns CollectionOpCallExp
	 *     NavigationOpCallExp returns CollectionOpCallExp
	 *     CollectionOpCall returns CollectionOpCallExp
	 *
	 * Constraint:
	 *     (name=CollectionOperationID (arguments+=OclExpression arguments+=OclExpression*)?)
	 */
	protected void sequence_CollectionOpCall(ISerializationContext context, CollectionOpCallExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns ComOpCallExp
	 *     ImpliesOpExp returns ComOpCallExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns ComOpCallExp
	 *     XorOpExp returns ComOpCallExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns ComOpCallExp
	 *     OrOpExp returns ComOpCallExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns ComOpCallExp
	 *     AndOpExp returns ComOpCallExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns ComOpCallExp
	 *     EqOpExp returns ComOpCallExp
	 *     EqOpExp.EqOpCallExp_1_0 returns ComOpCallExp
	 *     ComparisonOpExp returns ComOpCallExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns ComOpCallExp
	 *
	 * Constraint:
	 *     (source=ComparisonOpExp_ComOpCallExp_1_0 (name='>' | name='<' | name='>=' | name='<=') target=AdditionOpExp)
	 */
	protected void sequence_ComparisonOpExp(ISerializationContext context, ComOpCallExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElseIfThenExp returns ElseIfThenExp
	 *
	 * Constraint:
	 *     (name='elseif' condition=OclExpression then=OclExpression)
	 */
	protected void sequence_ElseIfThenExp(ISerializationContext context, ElseIfThenExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.OCL_EXPRESSION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.OCL_EXPRESSION__NAME));
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.ELSE_IF_THEN_EXP__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.ELSE_IF_THEN_EXP__CONDITION));
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.ELSE_IF_THEN_EXP__THEN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.ELSE_IF_THEN_EXP__THEN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElseIfThenExpAccess().getNameElseifKeyword_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getElseIfThenExpAccess().getConditionOclExpressionParserRuleCall_2_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getElseIfThenExpAccess().getThenOclExpressionParserRuleCall_4_0(), semanticObject.getThen());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclType returns EnvType
	 *     EnvType returns EnvType
	 *
	 * Constraint:
	 *     name='Env'
	 */
	protected void sequence_EnvType(ISerializationContext context, EnvType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.ENV_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.ENV_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnvTypeAccess().getNameEnvKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns EqOpCallExp
	 *     ImpliesOpExp returns EqOpCallExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns EqOpCallExp
	 *     XorOpExp returns EqOpCallExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns EqOpCallExp
	 *     OrOpExp returns EqOpCallExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns EqOpCallExp
	 *     AndOpExp returns EqOpCallExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns EqOpCallExp
	 *     EqOpExp returns EqOpCallExp
	 *     EqOpExp.EqOpCallExp_1_0 returns EqOpCallExp
	 *
	 * Constraint:
	 *     (source=EqOpExp_EqOpCallExp_1_0 (name='<>' | name='=') target=ComparisonOpExp)
	 */
	protected void sequence_EqOpExp(ISerializationContext context, EqOpCallExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns IfExp
	 *     ImpliesOpExp returns IfExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns IfExp
	 *     XorOpExp returns IfExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns IfExp
	 *     OrOpExp returns IfExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns IfExp
	 *     AndOpExp returns IfExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns IfExp
	 *     EqOpExp returns IfExp
	 *     EqOpExp.EqOpCallExp_1_0 returns IfExp
	 *     ComparisonOpExp returns IfExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns IfExp
	 *     AdditionOpExp returns IfExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns IfExp
	 *     MultiOpExp returns IfExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns IfExp
	 *     NavOpExp returns IfExp
	 *     NavOpExp.NavigationExp_1_0 returns IfExp
	 *     NavigationOpCallExp returns IfExp
	 *     PrimaryExp returns IfExp
	 *     IfExp returns IfExp
	 *
	 * Constraint:
	 *     (name='if' condition=OclExpression then=OclExpression ifThen+=ElseIfThenExp* else=OclExpression)
	 */
	protected void sequence_IfExp(ISerializationContext context, IfExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.IMPORT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.IMPORT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclType returns IntegerType
	 *     IntegerType returns IntegerType
	 *
	 * Constraint:
	 *     name='Integer'
	 */
	protected void sequence_IntegerType(ISerializationContext context, IntegerType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.INTEGER_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.INTEGER_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegerTypeAccess().getNameIntegerKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns InvalidLiteralExp
	 *     ImpliesOpExp returns InvalidLiteralExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns InvalidLiteralExp
	 *     XorOpExp returns InvalidLiteralExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns InvalidLiteralExp
	 *     OrOpExp returns InvalidLiteralExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns InvalidLiteralExp
	 *     AndOpExp returns InvalidLiteralExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns InvalidLiteralExp
	 *     EqOpExp returns InvalidLiteralExp
	 *     EqOpExp.EqOpCallExp_1_0 returns InvalidLiteralExp
	 *     ComparisonOpExp returns InvalidLiteralExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns InvalidLiteralExp
	 *     AdditionOpExp returns InvalidLiteralExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns InvalidLiteralExp
	 *     MultiOpExp returns InvalidLiteralExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns InvalidLiteralExp
	 *     NavOpExp returns InvalidLiteralExp
	 *     NavOpExp.NavigationExp_1_0 returns InvalidLiteralExp
	 *     NavigationOpCallExp returns InvalidLiteralExp
	 *     PrimaryExp returns InvalidLiteralExp
	 *     PrimitiveExp returns InvalidLiteralExp
	 *     InvalidExp returns InvalidLiteralExp
	 *
	 * Constraint:
	 *     {InvalidLiteralExp}
	 */
	protected void sequence_InvalidExp(ISerializationContext context, InvalidLiteralExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns IterateExp
	 *     ImpliesOpExp returns IterateExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns IterateExp
	 *     XorOpExp returns IterateExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns IterateExp
	 *     OrOpExp returns IterateExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns IterateExp
	 *     AndOpExp returns IterateExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns IterateExp
	 *     EqOpExp returns IterateExp
	 *     EqOpExp.EqOpCallExp_1_0 returns IterateExp
	 *     ComparisonOpExp returns IterateExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns IterateExp
	 *     AdditionOpExp returns IterateExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns IterateExp
	 *     MultiOpExp returns IterateExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns IterateExp
	 *     NavOpExp returns IterateExp
	 *     NavOpExp.NavigationExp_1_0 returns IterateExp
	 *     NavigationOpCallExp returns IterateExp
	 *     IterateExp returns IterateExp
	 *
	 * Constraint:
	 *     (name='iterate' iterators+=Iterator iterators+=Iterator* result=LocalVariable body=OclExpression)
	 */
	protected void sequence_IterateExp(ISerializationContext context, IterateExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns IteratorExp
	 *     ImpliesOpExp returns IteratorExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns IteratorExp
	 *     XorOpExp returns IteratorExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns IteratorExp
	 *     OrOpExp returns IteratorExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns IteratorExp
	 *     AndOpExp returns IteratorExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns IteratorExp
	 *     EqOpExp returns IteratorExp
	 *     EqOpExp.EqOpCallExp_1_0 returns IteratorExp
	 *     ComparisonOpExp returns IteratorExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns IteratorExp
	 *     AdditionOpExp returns IteratorExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns IteratorExp
	 *     MultiOpExp returns IteratorExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns IteratorExp
	 *     NavOpExp returns IteratorExp
	 *     NavOpExp.NavigationExp_1_0 returns IteratorExp
	 *     NavigationOpCallExp returns IteratorExp
	 *     IteratorExp returns IteratorExp
	 *
	 * Constraint:
	 *     (name=IterativeOperationID iterators+=Iterator iterators+=Iterator* body=OclExpression)
	 */
	protected void sequence_IteratorExp(ISerializationContext context, IteratorExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Iterator returns Iterator
	 *
	 * Constraint:
	 *     (name=ID type=OclType?)
	 */
	protected void sequence_Iterator(ISerializationContext context, Iterator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns LambdaExp
	 *     ImpliesOpExp returns LambdaExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns LambdaExp
	 *     XorOpExp returns LambdaExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns LambdaExp
	 *     OrOpExp returns LambdaExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns LambdaExp
	 *     AndOpExp returns LambdaExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns LambdaExp
	 *     EqOpExp returns LambdaExp
	 *     EqOpExp.EqOpCallExp_1_0 returns LambdaExp
	 *     ComparisonOpExp returns LambdaExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns LambdaExp
	 *     AdditionOpExp returns LambdaExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns LambdaExp
	 *     MultiOpExp returns LambdaExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns LambdaExp
	 *     NavOpExp returns LambdaExp
	 *     NavOpExp.NavigationExp_1_0 returns LambdaExp
	 *     NavigationOpCallExp returns LambdaExp
	 *     PrimaryExp returns LambdaExp
	 *     LambdaExp returns LambdaExp
	 *
	 * Constraint:
	 *     (name='Lambda' expression=OclExpression)
	 */
	protected void sequence_LambdaExp(ISerializationContext context, LambdaExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.OCL_EXPRESSION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.OCL_EXPRESSION__NAME));
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.LAMBDA_EXP__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.LAMBDA_EXP__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLambdaExpAccess().getNameLambdaKeyword_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLambdaExpAccess().getExpressionOclExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclType returns LambdaType
	 *     LambdaType returns LambdaType
	 *
	 * Constraint:
	 *     (name='Lambda' argsTypes+=OclType argsTypes+=OclType* returnType=OclType)
	 */
	protected void sequence_LambdaType(ISerializationContext context, LambdaType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LetExp returns OclExpression
	 *
	 * Constraint:
	 *     (name='let' variable=LocalVariable in=OclExpression)
	 */
	protected void sequence_LetExp(ISerializationContext context, OclExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.OCL_EXPRESSION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.OCL_EXPRESSION__NAME));
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.OCL_EXPRESSION__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.OCL_EXPRESSION__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.OCL_EXPRESSION__IN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.OCL_EXPRESSION__IN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLetExpAccess().getNameLetKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLetExpAccess().getVariableLocalVariableParserRuleCall_1_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getLetExpAccess().getInOclExpressionParserRuleCall_3_0(), semanticObject.getIn());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns OclExpression
	 *
	 * Constraint:
	 *     (
	 *         (name='let' variable=LocalVariable in=OclExpression) | 
	 *         (name=UnaryOperator target=OclExpression) | 
	 *         (model=OclModel name='::' elements+=ID elements+=ID* target=AllInstancesOpCall?)
	 *     )
	 */
	protected void sequence_LetExp_OclModelElementExp_UnaryOpExp(ISerializationContext context, OclExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LocalVariable returns LocalVariable
	 *
	 * Constraint:
	 *     (name=ID type=OclType initExp=OclExpression)
	 */
	protected void sequence_LocalVariable(ISerializationContext context, LocalVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.LOCAL_VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.LOCAL_VARIABLE__NAME));
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.LOCAL_VARIABLE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.LOCAL_VARIABLE__TYPE));
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.LOCAL_VARIABLE__INIT_EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.LOCAL_VARIABLE__INIT_EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLocalVariableAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLocalVariableAccess().getTypeOclTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getLocalVariableAccess().getInitExpOclExpressionParserRuleCall_4_0(), semanticObject.getInitExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclType returns MapType
	 *     MapType returns MapType
	 *
	 * Constraint:
	 *     (name='Map' keyType=OclType valueType=OclType)
	 */
	protected void sequence_MapType(ISerializationContext context, MapType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.MAP_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.MAP_TYPE__NAME));
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.MAP_TYPE__KEY_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.MAP_TYPE__KEY_TYPE));
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.MAP_TYPE__VALUE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.MAP_TYPE__VALUE_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMapTypeAccess().getNameMapKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMapTypeAccess().getKeyTypeOclTypeParserRuleCall_2_0(), semanticObject.getKeyType());
		feeder.accept(grammarAccess.getMapTypeAccess().getValueTypeOclTypeParserRuleCall_4_0(), semanticObject.getValueType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Module returns Module
	 *
	 * Constraint:
	 *     (name=ID source=OclModel input=OclModel (imports+=Import imports+=Import*)? (elements+=ModuleElement elements+=ModuleElement*)?)
	 */
	protected void sequence_Module(ISerializationContext context, Module semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns MulOpCallExp
	 *     ImpliesOpExp returns MulOpCallExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns MulOpCallExp
	 *     XorOpExp returns MulOpCallExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns MulOpCallExp
	 *     OrOpExp returns MulOpCallExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns MulOpCallExp
	 *     AndOpExp returns MulOpCallExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns MulOpCallExp
	 *     EqOpExp returns MulOpCallExp
	 *     EqOpExp.EqOpCallExp_1_0 returns MulOpCallExp
	 *     ComparisonOpExp returns MulOpCallExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns MulOpCallExp
	 *     AdditionOpExp returns MulOpCallExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns MulOpCallExp
	 *     MultiOpExp returns MulOpCallExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns MulOpCallExp
	 *
	 * Constraint:
	 *     (source=MultiOpExp_MulOpCallExp_1_0 (name='*' | name='/') target=NavOpExp)
	 */
	protected void sequence_MultiOpExp(ISerializationContext context, MulOpCallExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns NavigationExp
	 *     ImpliesOpExp returns NavigationExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns NavigationExp
	 *     XorOpExp returns NavigationExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns NavigationExp
	 *     OrOpExp returns NavigationExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns NavigationExp
	 *     AndOpExp returns NavigationExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns NavigationExp
	 *     EqOpExp returns NavigationExp
	 *     EqOpExp.EqOpCallExp_1_0 returns NavigationExp
	 *     ComparisonOpExp returns NavigationExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns NavigationExp
	 *     AdditionOpExp returns NavigationExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns NavigationExp
	 *     MultiOpExp returns NavigationExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns NavigationExp
	 *     NavOpExp returns NavigationExp
	 *     NavOpExp.NavigationExp_1_0 returns NavigationExp
	 *
	 * Constraint:
	 *     (source=NavOpExp_NavigationExp_1_0 name=NavigationOperator target=NavigationOpCallExp)
	 */
	protected void sequence_NavOpExp(ISerializationContext context, NavigationExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.NAVIGATION_EXP__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.NAVIGATION_EXP__SOURCE));
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.OCL_EXPRESSION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.OCL_EXPRESSION__NAME));
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.OCL_EXPRESSION__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.OCL_EXPRESSION__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNavOpExpAccess().getNavigationExpSourceAction_1_0(), semanticObject.getSource());
		feeder.accept(grammarAccess.getNavOpExpAccess().getNameNavigationOperatorParserRuleCall_1_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getNavOpExpAccess().getTargetNavigationOpCallExpParserRuleCall_1_2_0(), semanticObject.getTarget());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns NavigationOrAttributeCall
	 *     ImpliesOpExp returns NavigationOrAttributeCall
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns NavigationOrAttributeCall
	 *     XorOpExp returns NavigationOrAttributeCall
	 *     XorOpExp.BoolOpCallExp_1_0 returns NavigationOrAttributeCall
	 *     OrOpExp returns NavigationOrAttributeCall
	 *     OrOpExp.BoolOpCallExp_1_0 returns NavigationOrAttributeCall
	 *     AndOpExp returns NavigationOrAttributeCall
	 *     AndOpExp.BoolOpCallExp_1_0 returns NavigationOrAttributeCall
	 *     EqOpExp returns NavigationOrAttributeCall
	 *     EqOpExp.EqOpCallExp_1_0 returns NavigationOrAttributeCall
	 *     ComparisonOpExp returns NavigationOrAttributeCall
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns NavigationOrAttributeCall
	 *     AdditionOpExp returns NavigationOrAttributeCall
	 *     AdditionOpExp.AddOpCallExp_1_0 returns NavigationOrAttributeCall
	 *     MultiOpExp returns NavigationOrAttributeCall
	 *     MultiOpExp.MulOpCallExp_1_0 returns NavigationOrAttributeCall
	 *     NavOpExp returns NavigationOrAttributeCall
	 *     NavOpExp.NavigationExp_1_0 returns NavigationOrAttributeCall
	 *     NavigationOpCallExp returns NavigationOrAttributeCall
	 *     NavigationOrAttributeCall returns NavigationOrAttributeCall
	 *
	 * Constraint:
	 *     feature=ID
	 */
	protected void sequence_NavigationOrAttributeCall(ISerializationContext context, NavigationOrAttributeCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.NAVIGATION_OR_ATTRIBUTE_CALL__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.NAVIGATION_OR_ATTRIBUTE_CALL__FEATURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNavigationOrAttributeCallAccess().getFeatureIDTerminalRuleCall_1_0(), semanticObject.getFeature());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns NestedExp
	 *     ImpliesOpExp returns NestedExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns NestedExp
	 *     XorOpExp returns NestedExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns NestedExp
	 *     OrOpExp returns NestedExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns NestedExp
	 *     AndOpExp returns NestedExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns NestedExp
	 *     EqOpExp returns NestedExp
	 *     EqOpExp.EqOpCallExp_1_0 returns NestedExp
	 *     ComparisonOpExp returns NestedExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns NestedExp
	 *     AdditionOpExp returns NestedExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns NestedExp
	 *     MultiOpExp returns NestedExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns NestedExp
	 *     NavOpExp returns NestedExp
	 *     NavOpExp.NavigationExp_1_0 returns NestedExp
	 *     NavigationOpCallExp returns NestedExp
	 *     PrimaryExp returns NestedExp
	 *     NestedExp returns NestedExp
	 *
	 * Constraint:
	 *     exp=OclExpression
	 */
	protected void sequence_NestedExp(ISerializationContext context, NestedExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.NESTED_EXP__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.NESTED_EXP__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNestedExpAccess().getExpOclExpressionParserRuleCall_2_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns NullLiteralExp
	 *     ImpliesOpExp returns NullLiteralExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns NullLiteralExp
	 *     XorOpExp returns NullLiteralExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns NullLiteralExp
	 *     OrOpExp returns NullLiteralExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns NullLiteralExp
	 *     AndOpExp returns NullLiteralExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns NullLiteralExp
	 *     EqOpExp returns NullLiteralExp
	 *     EqOpExp.EqOpCallExp_1_0 returns NullLiteralExp
	 *     ComparisonOpExp returns NullLiteralExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns NullLiteralExp
	 *     AdditionOpExp returns NullLiteralExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns NullLiteralExp
	 *     MultiOpExp returns NullLiteralExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns NullLiteralExp
	 *     NavOpExp returns NullLiteralExp
	 *     NavOpExp.NavigationExp_1_0 returns NullLiteralExp
	 *     NavigationOpCallExp returns NullLiteralExp
	 *     PrimaryExp returns NullLiteralExp
	 *     PrimitiveExp returns NullLiteralExp
	 *     NullExp returns NullLiteralExp
	 *
	 * Constraint:
	 *     {NullLiteralExp}
	 */
	protected void sequence_NullExp(ISerializationContext context, NullLiteralExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns NumberLiteralExp
	 *     ImpliesOpExp returns NumberLiteralExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns NumberLiteralExp
	 *     XorOpExp returns NumberLiteralExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns NumberLiteralExp
	 *     OrOpExp returns NumberLiteralExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns NumberLiteralExp
	 *     AndOpExp returns NumberLiteralExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns NumberLiteralExp
	 *     EqOpExp returns NumberLiteralExp
	 *     EqOpExp.EqOpCallExp_1_0 returns NumberLiteralExp
	 *     ComparisonOpExp returns NumberLiteralExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns NumberLiteralExp
	 *     AdditionOpExp returns NumberLiteralExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns NumberLiteralExp
	 *     MultiOpExp returns NumberLiteralExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns NumberLiteralExp
	 *     NavOpExp returns NumberLiteralExp
	 *     NavOpExp.NavigationExp_1_0 returns NumberLiteralExp
	 *     NavigationOpCallExp returns NumberLiteralExp
	 *     PrimaryExp returns NumberLiteralExp
	 *     PrimitiveExp returns NumberLiteralExp
	 *     NumberExp returns NumberLiteralExp
	 *
	 * Constraint:
	 *     symbol=INT
	 */
	protected void sequence_NumberExp(ISerializationContext context, NumberLiteralExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.NUMBER_LITERAL_EXP__SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.NUMBER_LITERAL_EXP__SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberExpAccess().getSymbolINTTerminalRuleCall_0(), semanticObject.getSymbol());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclType returns OclAnyType
	 *     OclAnyType returns OclAnyType
	 *
	 * Constraint:
	 *     name='OclAny'
	 */
	protected void sequence_OclAnyType(ISerializationContext context, OclAnyType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.OCL_ANY_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.OCL_ANY_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOclAnyTypeAccess().getNameOclAnyKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ImpliesOpExp returns OclExpression
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns OclExpression
	 *     XorOpExp returns OclExpression
	 *     XorOpExp.BoolOpCallExp_1_0 returns OclExpression
	 *     OrOpExp returns OclExpression
	 *     OrOpExp.BoolOpCallExp_1_0 returns OclExpression
	 *     AndOpExp returns OclExpression
	 *     AndOpExp.BoolOpCallExp_1_0 returns OclExpression
	 *     EqOpExp returns OclExpression
	 *     EqOpExp.EqOpCallExp_1_0 returns OclExpression
	 *     ComparisonOpExp returns OclExpression
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns OclExpression
	 *     AdditionOpExp returns OclExpression
	 *     AdditionOpExp.AddOpCallExp_1_0 returns OclExpression
	 *     MultiOpExp returns OclExpression
	 *     MultiOpExp.MulOpCallExp_1_0 returns OclExpression
	 *     NavOpExp returns OclExpression
	 *     NavOpExp.NavigationExp_1_0 returns OclExpression
	 *     NavigationOpCallExp returns OclExpression
	 *     OclModelElementExp returns OclExpression
	 *     PrimaryExp returns OclExpression
	 *
	 * Constraint:
	 *     (model=OclModel name='::' elements+=ID elements+=ID* target=AllInstancesOpCall?)
	 */
	protected void sequence_OclModelElementExp(ISerializationContext context, OclExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclType returns OclModelElementExp
	 *     OclModelElement returns OclModelElementExp
	 *
	 * Constraint:
	 *     (model=OclModel name=ID)
	 */
	protected void sequence_OclModelElement(ISerializationContext context, OclModelElementExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.OCL_MODEL_ELEMENT_EXP__MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.OCL_MODEL_ELEMENT_EXP__MODEL));
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.OCL_MODEL_ELEMENT_EXP__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.OCL_MODEL_ELEMENT_EXP__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOclModelElementAccess().getModelOclModelParserRuleCall_0_0(), semanticObject.getModel());
		feeder.accept(grammarAccess.getOclModelElementAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclModel returns OclModel
	 *
	 * Constraint:
	 *     (name=ID uri=URI_?)
	 */
	protected void sequence_OclModel(ISerializationContext context, OclModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns OperationCall
	 *     ImpliesOpExp returns OperationCall
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns OperationCall
	 *     XorOpExp returns OperationCall
	 *     XorOpExp.BoolOpCallExp_1_0 returns OperationCall
	 *     OrOpExp returns OperationCall
	 *     OrOpExp.BoolOpCallExp_1_0 returns OperationCall
	 *     AndOpExp returns OperationCall
	 *     AndOpExp.BoolOpCallExp_1_0 returns OperationCall
	 *     EqOpExp returns OperationCall
	 *     EqOpExp.EqOpCallExp_1_0 returns OperationCall
	 *     ComparisonOpExp returns OperationCall
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns OperationCall
	 *     AdditionOpExp returns OperationCall
	 *     AdditionOpExp.AddOpCallExp_1_0 returns OperationCall
	 *     MultiOpExp returns OperationCall
	 *     MultiOpExp.MulOpCallExp_1_0 returns OperationCall
	 *     NavOpExp returns OperationCall
	 *     NavOpExp.NavigationExp_1_0 returns OperationCall
	 *     NavigationOpCallExp returns OperationCall
	 *     OperationCall returns OperationCall
	 *
	 * Constraint:
	 *     (name=ID (arguments+=OclExpression arguments+=OclExpression*)?)
	 */
	protected void sequence_OperationCall(ISerializationContext context, OperationCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclType returns OrderedSetType
	 *     OrderedSetType returns OrderedSetType
	 *
	 * Constraint:
	 *     (name='OrderedSet' elementType=OclType)
	 */
	protected void sequence_OrderedSetType(ISerializationContext context, OrderedSetType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.ORDERED_SET_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.ORDERED_SET_TYPE__NAME));
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.ORDERED_SET_TYPE__ELEMENT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.ORDERED_SET_TYPE__ELEMENT_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrderedSetTypeAccess().getNameOrderedSetKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getOrderedSetTypeAccess().getElementTypeOclTypeParserRuleCall_2_0(), semanticObject.getElementType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ModuleElement returns Query
	 *     Query returns Query
	 *
	 * Constraint:
	 *     (name=ID body=OclExpression)
	 */
	protected void sequence_Query(ISerializationContext context, Query semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.QUERY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.QUERY__NAME));
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.QUERY__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.QUERY__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getQueryAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getQueryAccess().getBodyOclExpressionParserRuleCall_4_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclType returns RealType
	 *     RealType returns RealType
	 *
	 * Constraint:
	 *     name='Real'
	 */
	protected void sequence_RealType(ISerializationContext context, RealType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.REAL_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.REAL_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRealTypeAccess().getNameRealKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns SelfExp
	 *     ImpliesOpExp returns SelfExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns SelfExp
	 *     XorOpExp returns SelfExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns SelfExp
	 *     OrOpExp returns SelfExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns SelfExp
	 *     AndOpExp returns SelfExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns SelfExp
	 *     EqOpExp returns SelfExp
	 *     EqOpExp.EqOpCallExp_1_0 returns SelfExp
	 *     ComparisonOpExp returns SelfExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns SelfExp
	 *     AdditionOpExp returns SelfExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns SelfExp
	 *     MultiOpExp returns SelfExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns SelfExp
	 *     NavOpExp returns SelfExp
	 *     NavOpExp.NavigationExp_1_0 returns SelfExp
	 *     NavigationOpCallExp returns SelfExp
	 *     PrimaryExp returns SelfExp
	 *     SeflExp returns SelfExp
	 *
	 * Constraint:
	 *     name='self'
	 */
	protected void sequence_SeflExp(ISerializationContext context, SelfExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.OCL_EXPRESSION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.OCL_EXPRESSION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSeflExpAccess().getNameSelfKeyword_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclType returns SequenceType
	 *     SequenceType returns SequenceType
	 *
	 * Constraint:
	 *     (name='Sequence' elementType=OclType)
	 */
	protected void sequence_SequenceType(ISerializationContext context, SequenceType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.SEQUENCE_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.SEQUENCE_TYPE__NAME));
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.SEQUENCE_TYPE__ELEMENT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.SEQUENCE_TYPE__ELEMENT_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSequenceTypeAccess().getNameSequenceKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSequenceTypeAccess().getElementTypeOclTypeParserRuleCall_2_0(), semanticObject.getElementType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclType returns SetType
	 *     SetType returns SetType
	 *
	 * Constraint:
	 *     (name='Set' elementType=OclType)
	 */
	protected void sequence_SetType(ISerializationContext context, SetType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.SET_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.SET_TYPE__NAME));
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.SET_TYPE__ELEMENT_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.SET_TYPE__ELEMENT_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetTypeAccess().getNameSetKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSetTypeAccess().getElementTypeOclTypeParserRuleCall_2_0(), semanticObject.getElementType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns StringLiteralExp
	 *     ImpliesOpExp returns StringLiteralExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns StringLiteralExp
	 *     XorOpExp returns StringLiteralExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns StringLiteralExp
	 *     OrOpExp returns StringLiteralExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns StringLiteralExp
	 *     AndOpExp returns StringLiteralExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns StringLiteralExp
	 *     EqOpExp returns StringLiteralExp
	 *     EqOpExp.EqOpCallExp_1_0 returns StringLiteralExp
	 *     ComparisonOpExp returns StringLiteralExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns StringLiteralExp
	 *     AdditionOpExp returns StringLiteralExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns StringLiteralExp
	 *     MultiOpExp returns StringLiteralExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns StringLiteralExp
	 *     NavOpExp returns StringLiteralExp
	 *     NavOpExp.NavigationExp_1_0 returns StringLiteralExp
	 *     NavigationOpCallExp returns StringLiteralExp
	 *     PrimaryExp returns StringLiteralExp
	 *     PrimitiveExp returns StringLiteralExp
	 *     StringExp returns StringLiteralExp
	 *
	 * Constraint:
	 *     segments+=STRING+
	 */
	protected void sequence_StringExp(ISerializationContext context, StringLiteralExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OclType returns StringType
	 *     StringType returns StringType
	 *
	 * Constraint:
	 *     name='String'
	 */
	protected void sequence_StringType(ISerializationContext context, StringType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.STRING_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.STRING_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringTypeAccess().getNameStringKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns TupleExp
	 *     ImpliesOpExp returns TupleExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns TupleExp
	 *     XorOpExp returns TupleExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns TupleExp
	 *     OrOpExp returns TupleExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns TupleExp
	 *     AndOpExp returns TupleExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns TupleExp
	 *     EqOpExp returns TupleExp
	 *     EqOpExp.EqOpCallExp_1_0 returns TupleExp
	 *     ComparisonOpExp returns TupleExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns TupleExp
	 *     AdditionOpExp returns TupleExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns TupleExp
	 *     MultiOpExp returns TupleExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns TupleExp
	 *     NavOpExp returns TupleExp
	 *     NavOpExp.NavigationExp_1_0 returns TupleExp
	 *     NavigationOpCallExp returns TupleExp
	 *     PrimaryExp returns TupleExp
	 *     TupleExp returns TupleExp
	 *
	 * Constraint:
	 *     (name='Tuple' parts+=TuplePart parts+=TuplePart*)
	 */
	protected void sequence_TupleExp(ISerializationContext context, TupleExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TuplePart returns TuplePart
	 *
	 * Constraint:
	 *     (name=STRING type=OclType? init=OclExpression)
	 */
	protected void sequence_TuplePart(ISerializationContext context, TuplePart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     URI_ returns URI_
	 *
	 * Constraint:
	 *     (scheme=SCHEME authority=AUTHORITY fragment_=FRAGMENT)
	 */
	protected void sequence_URI_(ISerializationContext context, URI_ semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.URI___SCHEME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.URI___SCHEME));
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.URI___AUTHORITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.URI___AUTHORITY));
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.URI___FRAGMENT_) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.URI___FRAGMENT_));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getURI_Access().getSchemeSCHEMETerminalRuleCall_1_0(), semanticObject.getScheme());
		feeder.accept(grammarAccess.getURI_Access().getAuthorityAUTHORITYParserRuleCall_3_0(), semanticObject.getAuthority());
		feeder.accept(grammarAccess.getURI_Access().getFragment_FRAGMENTParserRuleCall_5_0(), semanticObject.getFragment_());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     UnaryOpExp returns OclExpression
	 *
	 * Constraint:
	 *     (name=UnaryOperator target=OclExpression)
	 */
	protected void sequence_UnaryOpExp(ISerializationContext context, OclExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.OCL_EXPRESSION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.OCL_EXPRESSION__NAME));
			if (transientValues.isValueTransient(semanticObject, DoclPackage.Literals.OCL_EXPRESSION__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DoclPackage.Literals.OCL_EXPRESSION__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryOpExpAccess().getNameUnaryOperatorParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getUnaryOpExpAccess().getTargetOclExpressionParserRuleCall_1_0(), semanticObject.getTarget());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OclExpression returns UnlimitedNaturalLiteralExp
	 *     ImpliesOpExp returns UnlimitedNaturalLiteralExp
	 *     ImpliesOpExp.BoolOpCallExp_1_0 returns UnlimitedNaturalLiteralExp
	 *     XorOpExp returns UnlimitedNaturalLiteralExp
	 *     XorOpExp.BoolOpCallExp_1_0 returns UnlimitedNaturalLiteralExp
	 *     OrOpExp returns UnlimitedNaturalLiteralExp
	 *     OrOpExp.BoolOpCallExp_1_0 returns UnlimitedNaturalLiteralExp
	 *     AndOpExp returns UnlimitedNaturalLiteralExp
	 *     AndOpExp.BoolOpCallExp_1_0 returns UnlimitedNaturalLiteralExp
	 *     EqOpExp returns UnlimitedNaturalLiteralExp
	 *     EqOpExp.EqOpCallExp_1_0 returns UnlimitedNaturalLiteralExp
	 *     ComparisonOpExp returns UnlimitedNaturalLiteralExp
	 *     ComparisonOpExp.ComOpCallExp_1_0 returns UnlimitedNaturalLiteralExp
	 *     AdditionOpExp returns UnlimitedNaturalLiteralExp
	 *     AdditionOpExp.AddOpCallExp_1_0 returns UnlimitedNaturalLiteralExp
	 *     MultiOpExp returns UnlimitedNaturalLiteralExp
	 *     MultiOpExp.MulOpCallExp_1_0 returns UnlimitedNaturalLiteralExp
	 *     NavOpExp returns UnlimitedNaturalLiteralExp
	 *     NavOpExp.NavigationExp_1_0 returns UnlimitedNaturalLiteralExp
	 *     NavigationOpCallExp returns UnlimitedNaturalLiteralExp
	 *     PrimaryExp returns UnlimitedNaturalLiteralExp
	 *     PrimitiveExp returns UnlimitedNaturalLiteralExp
	 *     UnlimitedNaturalExp returns UnlimitedNaturalLiteralExp
	 *
	 * Constraint:
	 *     {UnlimitedNaturalLiteralExp}
	 */
	protected void sequence_UnlimitedNaturalExp(ISerializationContext context, UnlimitedNaturalLiteralExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
